#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <poll.h>
#include <net/if.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>

#define ETH_P_MIP 0x88B5  // Definere den spesifikke protokollen

// Maks bufferstørrelse for pakker
#define BUFFER_SIZE 2048
#define MAX_INTERFACES 10

int create_raw_socket(int protocol) {
    int sockfd;

    // Opprett en raw socket med AF_PACKET og SOCK_RAW
    if ((sockfd = socket(AF_PACKET, SOCK_RAW, htons(protocol))) == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    return sockfd;
}

void bind_socket_to_interface(int sockfd, const char *interface, int protocol) {
    struct sockaddr_ll sll;
    struct ifreq ifr;

    // Kopier interface navn til ifreq strukturen
    strncpy(ifr.ifr_name, interface, IFNAMSIZ);
    
    // Hent grensesnittets indeks
    if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1) {
        perror("Unable to get interface index");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    // Konfigurer sockaddr_ll for å binde til riktig interface
    memset(&sll, 0, sizeof(sll));
    sll.sll_family = AF_PACKET;
    sll.sll_ifindex = ifr.ifr_ifindex;
    sll.sll_protocol = htons(protocol);

    // Bind socket til grensesnittet
    if (bind(sockfd, (struct sockaddr *)&sll, sizeof(sll)) == -1) {
        perror("Socket binding failed");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
}

int main() {
    struct pollfd fds[MAX_INTERFACES];
    int num_interfaces = 0;
    char buffer[BUFFER_SIZE];

    // Grensesnitt du ønsker å lytte på
    const char *interfaces[] = {"eth0", "eth1", "wlan0"};
    int num_ifaces = sizeof(interfaces) / sizeof(interfaces[0]);

    // Opprett og bind sockets for hvert grensesnitt
    for (int i = 0; i < num_ifaces; i++) {
        int sockfd = create_raw_socket(ETH_P_MIP);
        bind_socket_to_interface(sockfd, interfaces[i], ETH_P_MIP);
        
        fds[num_interfaces].fd = sockfd;
        fds[num_interfaces].events = POLLIN;  // Overvåk lesing (input)
        num_interfaces++;
    }

    printf("Listening for packets on all interfaces...\n");

    while (1) {
        int ret = poll(fds, num_interfaces, -1);  // Blokkerer til en hendelse inntreffer

        if (ret > 0) {
            for (int i = 0; i < num_interfaces; i++) {
                if (fds[i].revents & POLLIN) {
                    // Mottak av en pakke
                    ssize_t len = recv(fds[i].fd, buffer, BUFFER_SIZE, 0);
                    if (len == -1) {
                        perror("Packet reception failed");
                    } else {
                        printf("Received packet of length %zd on interface %d\n", len, i);
                        // Her kan du behandle eller videresende pakken etter behov
                    }
                }
            }
        } else if (ret == -1) {
            perror("Poll failed");
            break;
        }
    }

    // Lukk alle sockets
    for (int i = 0; i < num_interfaces; i++) {
        close(fds[i].fd);
    }

    return 0;
}


///////////////////////////////////////////////////////////////////////////////////////////



